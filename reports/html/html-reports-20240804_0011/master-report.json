{"info":{"type":"runner","start":"2024-08-03T17:11:34.889Z","end":"2024-08-03T17:11:43.224Z","_duration":8335,"cid":"0-1","capabilities":{"myChromeBrowser":{"acceptInsecureCerts":false,"browserName":"chrome","browserVersion":"127.0.6533.89","chrome":{"chromedriverVersion":"127.0.6533.88 (a2d0cb026721e4644e489b8ebb07038ca4e4351c-refs/branch-heads/6533@{#1846})","userDataDir":"C:\\Users\\MOCHAM~1\\AppData\\Local\\Temp\\scoped_dir12448_14090829"},"fedcm:accounts":true,"goog:chromeOptions":{"debuggerAddress":"localhost:51168"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"windows","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:extension:minPinLength":true,"webauthn:extension:prf":true,"webauthn:virtualAuthenticators":true,"wdio:driverPID":12448,"sessionId":"5b1143dcee33236458e0e592fe1e0a75"}},"sanitizedCapabilities":"","config":{"isW3C":true,"isChrome":false,"isFirefox":false,"isMobile":false,"isIOS":false,"isAndroid":false,"isSauce":false,"isSeleniumStandalone":false,"isBidi":false,"isChromium":false,"sessionId":"","logLevel":"info","capabilities":{},"protocol":"http","hostname":"0.0.0.0","path":"/"},"specs":["file:///E:/github/sbcode-wdio-cucumber-kasiraja/features/register.feature"],"isMultiremote":true,"instanceOptions":{"5b1143dcee33236458e0e592fe1e0a75":{"protocol":"http","hostname":"0.0.0.0","path":"/","capabilities":{"browserName":"chrome","goog:chromeOptions":{"binary":"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"}},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"cacheDir":"C:\\Users\\MOCHAM~1\\AppData\\Local\\Temp","port":51154,"requestedCapabilities":{"browserName":"chrome","goog:chromeOptions":{"binary":"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe"}},"automationProtocol":"webdriver","waitforInterval":500,"waitforTimeout":10000,"onReload":[],"beforeCommand":[],"afterCommand":[],"rootDir":"E:\\github\\sbcode-wdio-cucumber-kasiraja","specs":["./features/**/*.feature"],"suites":{},"exclude":[],"groupLogsByTestSpec":false,"excludeDriverLogs":[],"bail":0,"framework":"cucumber","reporters":["spec","cucumberjs-json",["html-nice",{"outputDir":"./reports/html/html-reports-20240804_0011","filename":"report-feature.html","reportTitle":"Report Feature","browserName":"Chrome","linkScreenshots":false,"showInBrowser":false,"collapseTests":false,"useOnAfterCommandForScreenshot":false}]],"services":[],"maxInstances":5,"maxInstancesPerCapability":100,"injectGlobals":true,"filesToWatch":[],"execArgv":[],"runnerEnv":{},"runner":"local","shard":{"current":1,"total":1},"specFileRetries":0,"specFileRetriesDelay":0,"specFileRetriesDeferred":false,"reporterSyncInterval":100,"reporterSyncTimeout":5000,"cucumberFeaturesWithLineNumbers":[],"autoCompileOpts":{"autoCompile":true,"tsNodeOpts":{"transpileOnly":true},"babelOpts":{}},"mochaOpts":{"timeout":10000},"jasmineOpts":{"defaultTimeoutInterval":10000},"cucumberOpts":{"timeout":60000,"tags":"@positive","require":["./features/step-definitions/*.js"],"backtrace":false,"requireModule":[],"dryRun":false,"failFast":false,"name":[],"snippets":true,"source":true,"strict":false,"tagExpression":"","ignoreUndefinedDefinitions":false},"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[null],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[null],"onComplete":[null],"beforeAssertion":[],"afterAssertion":[],"beforeFeature":[null],"beforeScenario":[],"beforeStep":[],"afterStep":[],"afterScenario":[null],"afterFeature":[],"_":["./wdio.conf.js","./wdio.conf.js"],"cucumber-opts":{"tags":"@positive"},"$0":"node_modules\\@wdio\\cli\\bin\\wdio.js","ignoredWorkerServices":[]}},"retry":0,"failures":0,"retries":0},"metrics":{"passed":7,"skipped":0,"failed":0,"duration":7997,"start":"2024-08-03T17:11:35.067Z","end":"2024-08-03T17:11:43.064Z"},"title":"Master Report","suites":[{"type":"feature","start":"2024-08-03T17:11:35.067Z","end":"2024-08-03T17:11:43.064Z","_duration":7995,"uid":"register.feature:2:1","cid":"0-1","file":"E:\\github\\sbcode-wdio-cucumber-kasiraja\\features\\register.feature","title":"Register Feature","tags":[{"location":{"line":1,"column":1},"name":"@register","id":"b4917c05-23ee-4b26-b22c-6eec1a1c68ba"}],"tests":[],"hooks":[],"suites":[{"type":"scenario","start":"2024-08-03T17:11:35.123Z","end":"2024-08-03T17:11:43.061Z","_duration":7937,"uid":"0","cid":"0-1","file":"E:\\github\\sbcode-wdio-cucumber-kasiraja\\features\\register.feature","title":"Successful registration","fullTitle":"register.feature:2:1: Successful registration","tags":[{"name":"@register","astNodeId":"b4917c05-23ee-4b26-b22c-6eec1a1c68ba"},{"name":"@positive","astNodeId":"2b394df0-f995-4db0-8220-dd7c0222c179"}],"tests":[{"type":"test","start":"2024-08-03T17:11:35.134Z","end":"2024-08-03T17:11:36.329Z","_duration":1195,"uid":"96e5d207-c53d-4515-ab63-198b20c5df69","cid":"0-1","title":"Given user already on home page","fullTitle":"0: Given user already on home page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://kasirdemo.vercel.app/login"},"cid":"0-1","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://kasirdemo.vercel.app/login"},"result":{"value":null},"cid":"0-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-08-03T17:11:36.331Z","end":"2024-08-03T17:11:37.422Z","_duration":1091,"uid":"0efb0e34-f7e0-4ee2-bd0a-ba5d4cb5af35","cid":"0-1","title":"When user navigates to the registration page","fullTitle":"0: When user navigates to the registration page","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7"}},"cid":"0-1","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7","ELEMENT":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7"}]},"cid":"0-1","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7","ELEMENT":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7"}]},"result":{"value":true},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7"}},"cid":"0-1","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7/text","body":{},"cid":"0-1","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7/text","body":{},"result":{"value":"ingin mencoba, daftar ?"},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7"}},"cid":"0-1","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7/click","body":{},"cid":"0-1","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7/click","body":{},"result":{"value":null},"cid":"0-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-08-03T17:11:37.424Z","end":"2024-08-03T17:11:40.262Z","_duration":2838,"uid":"1d5b4dee-8d20-42a2-b144-7bf1a7fb9015","cid":"0-1","title":"And user input valid registration details with name \"dummyuser01\", email \"dummyuser01@mail.com\", and password \"password\"","fullTitle":"0: And user input valid registration details with name \"dummyuser01\", email \"dummyuser01@mail.com\", and password \"password\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//input[@id='name'][@type='text']\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElements","method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"cid":"0-1","type":"command"},{"command":"findElements","method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8"}]},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8"}},"cid":"0-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8/clear","body":{},"cid":"0-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8/clear","body":{},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8/value","body":{"text":"dummyuser01"},"cid":"0-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8/value","body":{"text":"dummyuser01"},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='email'][@type='email']"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='email'][@type='email']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.10"}},"cid":"0-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.10/clear","body":{},"cid":"0-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.10/clear","body":{},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.10/value","body":{"text":"dummyuser01@mail.com"},"cid":"0-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.10/value","body":{"text":"dummyuser01@mail.com"},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='password'][@type='password']"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='password'][@type='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.11"}},"cid":"0-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.11/clear","body":{},"cid":"0-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.11/clear","body":{},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.11/value","body":{"text":"password"},"cid":"0-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.11/value","body":{"text":"password"},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type='submit'][contains(text(), 'daftar')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type='submit'][contains(text(), 'daftar')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.16"}},"cid":"0-1","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.16/click","body":{},"cid":"0-1","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.16/click","body":{},"result":{"value":null},"cid":"0-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-08-03T17:11:40.264Z","end":"2024-08-03T17:11:43.055Z","_duration":2791,"uid":"8f593d3b-0345-4074-b95e-ab8d062a0d64","cid":"0-1","title":"Then user should be registered successfully","fullTitle":"0: Then user should be registered successfully","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21"}},"cid":"0-1","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21","ELEMENT":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21"}]},"cid":"0-1","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21","ELEMENT":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21"}]},"result":{"value":true},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21"}},"cid":"0-1","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21/text","body":{},"cid":"0-1","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21/text","body":{},"result":{"value":"Toko berhasil didaftarkan"},"cid":"0-1","type":"result"},{"command":"getUrl","method":"GET","endpoint":"/session/:sessionId/url","body":{},"cid":"0-1","type":"command"},{"command":"getUrl","method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://kasirdemo.vercel.app/login"},"cid":"0-1","type":"result"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"cid":"0-1","type":"command"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"cid":"0-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2024-08-03T17:11:35.126Z","end":"2024-08-03T17:11:35.131Z","_duration":5,"uid":"43d232b9-af36-47f9-b466-6ed2bacfcef2","cid":"0-1","title":"","parent":"0","errors":[]},{"type":"hook","start":"2024-08-03T17:11:43.057Z","end":"2024-08-03T17:11:43.058Z","_duration":1,"uid":"671d5a36-e825-4ff5-a8b1-4265862a952d","cid":"0-1","title":"","parent":"0","errors":[]}],"suites":[],"parent":"register.feature:2:1","hooksAndTests":[{"type":"hook","start":"2024-08-03T17:11:35.126Z","end":"2024-08-03T17:11:35.131Z","_duration":5,"uid":"43d232b9-af36-47f9-b466-6ed2bacfcef2","cid":"0-1","title":"","parent":"0","errors":[]},{"type":"test","start":"2024-08-03T17:11:35.134Z","end":"2024-08-03T17:11:36.329Z","_duration":1195,"uid":"96e5d207-c53d-4515-ab63-198b20c5df69","cid":"0-1","title":"Given user already on home page","fullTitle":"0: Given user already on home page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://kasirdemo.vercel.app/login"},"cid":"0-1","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://kasirdemo.vercel.app/login"},"result":{"value":null},"cid":"0-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-08-03T17:11:36.331Z","end":"2024-08-03T17:11:37.422Z","_duration":1091,"uid":"0efb0e34-f7e0-4ee2-bd0a-ba5d4cb5af35","cid":"0-1","title":"When user navigates to the registration page","fullTitle":"0: When user navigates to the registration page","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7"}},"cid":"0-1","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7","ELEMENT":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7"}]},"cid":"0-1","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7","ELEMENT":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7"}]},"result":{"value":true},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7"}},"cid":"0-1","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7/text","body":{},"cid":"0-1","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7/text","body":{},"result":{"value":"ingin mencoba, daftar ?"},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//a[contains(text(), 'daftar')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7"}},"cid":"0-1","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7/click","body":{},"cid":"0-1","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.7/click","body":{},"result":{"value":null},"cid":"0-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-08-03T17:11:37.424Z","end":"2024-08-03T17:11:40.262Z","_duration":2838,"uid":"1d5b4dee-8d20-42a2-b144-7bf1a7fb9015","cid":"0-1","title":"And user input valid registration details with name \"dummyuser01\", email \"dummyuser01@mail.com\", and password \"password\"","fullTitle":"0: And user input valid registration details with name \"dummyuser01\", email \"dummyuser01@mail.com\", and password \"password\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//input[@id='name'][@type='text']\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElements","method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"cid":"0-1","type":"command"},{"command":"findElements","method":"POST","endpoint":"/session/:sessionId/elements","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"result":{"value":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8"}]},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='name'][@type='text']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8"}},"cid":"0-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8/clear","body":{},"cid":"0-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8/clear","body":{},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8/value","body":{"text":"dummyuser01"},"cid":"0-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.8/value","body":{"text":"dummyuser01"},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='email'][@type='email']"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='email'][@type='email']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.10"}},"cid":"0-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.10/clear","body":{},"cid":"0-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.10/clear","body":{},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.10/value","body":{"text":"dummyuser01@mail.com"},"cid":"0-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.10/value","body":{"text":"dummyuser01@mail.com"},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='password'][@type='password']"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id='password'][@type='password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.11"}},"cid":"0-1","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.11/clear","body":{},"cid":"0-1","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.11/clear","body":{},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.11/value","body":{"text":"password"},"cid":"0-1","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.11/value","body":{"text":"password"},"result":{"value":null},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type='submit'][contains(text(), 'daftar')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type='submit'][contains(text(), 'daftar')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.16"}},"cid":"0-1","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.16/click","body":{},"cid":"0-1","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.16/click","body":{},"result":{"value":null},"cid":"0-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-08-03T17:11:40.264Z","end":"2024-08-03T17:11:43.055Z","_duration":2791,"uid":"8f593d3b-0345-4074-b95e-ab8d062a0d64","cid":"0-1","title":"Then user should be registered successfully","fullTitle":"0: Then user should be registered successfully","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21"}},"cid":"0-1","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21","ELEMENT":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21"}]},"cid":"0-1","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21","ELEMENT":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21"}]},"result":{"value":true},"cid":"0-1","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"cid":"0-1","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(@class, 'chakra-alert__title')][contains(text(), 'Toko berhasil didaftarkan')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21"}},"cid":"0-1","type":"result"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21/text","body":{},"cid":"0-1","type":"command"},{"command":"getElementText","method":"GET","endpoint":"/session/:sessionId/element/f.FF9FB85B746C77A8F3FF7CF55CA5A544.d.9385833BE2D1AA5AB0747E032B174560.e.21/text","body":{},"result":{"value":"Toko berhasil didaftarkan"},"cid":"0-1","type":"result"},{"command":"getUrl","method":"GET","endpoint":"/session/:sessionId/url","body":{},"cid":"0-1","type":"command"},{"command":"getUrl","method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://kasirdemo.vercel.app/login"},"cid":"0-1","type":"result"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"cid":"0-1","type":"command"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"cid":"0-1","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2024-08-03T17:11:43.057Z","end":"2024-08-03T17:11:43.058Z","_duration":1,"uid":"671d5a36-e825-4ff5-a8b1-4265862a952d","cid":"0-1","title":"","parent":"0","errors":[]}],"description":""}],"hooksAndTests":[],"description":""},{"type":"feature","start":"2024-08-03T17:11:35.224Z","end":"2024-08-03T17:11:42.158Z","_duration":6932,"uid":"login.feature:2:1","cid":"0-0","file":"E:\\github\\sbcode-wdio-cucumber-kasiraja\\features\\login.feature","title":"login","tags":[{"location":{"line":1,"column":1},"name":"@login","id":"8ada2090-f89b-443d-aa91-ea7799fd65b3"}],"tests":[],"hooks":[],"suites":[{"type":"scenario","start":"2024-08-03T17:11:35.297Z","end":"2024-08-03T17:11:42.154Z","_duration":6851,"uid":"0","cid":"0-0","file":"E:\\github\\sbcode-wdio-cucumber-kasiraja\\features\\login.feature","title":"Successful login","fullTitle":"login.feature:2:1: Successful login","tags":[{"name":"@login","astNodeId":"8ada2090-f89b-443d-aa91-ea7799fd65b3"},{"name":"@positive","astNodeId":"6da87d0e-6370-4640-9622-bbaab4e33539"}],"tests":[{"type":"test","start":"2024-08-03T17:11:35.308Z","end":"2024-08-03T17:11:35.594Z","_duration":286,"uid":"88b3e9f2-8191-454a-b0ca-b196adc44066","cid":"0-0","title":"Given user already on login page","fullTitle":"0: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://kasirdemo.vercel.app/login"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://kasirdemo.vercel.app/login"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-08-03T17:11:35.595Z","end":"2024-08-03T17:11:39.234Z","_duration":3639,"uid":"08658e70-4cc5-450b-a0f0-565706292fb9","cid":"0-0","title":"When user input valid login credentials with email \"dummyuser00@mail.com\" and password \"password\"","fullTitle":"0: When user input valid login credentials with email \"dummyuser00@mail.com\" and password \"password\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id= 'email']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id= 'email']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.2"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.2/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.2/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.2/value","body":{"text":"dummyuser00@mail.com"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.2/value","body":{"text":"dummyuser00@mail.com"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id= 'password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id= 'password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.3"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.3/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.3/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.3/value","body":{"text":"password"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.3/value","body":{"text":"password"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type= 'submit'][text()='login']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type= 'submit'][text()='login']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9/property/value","body":{},"result":{"value":""},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type= 'submit'][text()='login']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type= 'submit'][text()='login']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-08-03T17:11:39.236Z","end":"2024-08-03T17:11:42.141Z","_duration":2905,"uid":"db8fcf6d-d324-4ce0-9969-638906b2cde1","cid":"0-0","title":"Then user is successfully logged in and redirected to the dashboard page","fullTitle":"0: Then user is successfully logged in and redirected to the dashboard page","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11","ELEMENT":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11","ELEMENT":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11","ELEMENT":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11","ELEMENT":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"cid":"0-0","type":"command"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0}],"hooks":[{"type":"hook","start":"2024-08-03T17:11:35.300Z","end":"2024-08-03T17:11:35.305Z","_duration":5,"uid":"6b9e1096-83dd-4590-9c15-a57e9b1be861","cid":"0-0","title":"","parent":"0","errors":[]},{"type":"hook","start":"2024-08-03T17:11:42.143Z","end":"2024-08-03T17:11:42.146Z","_duration":3,"uid":"1d4774b3-3249-4d7e-8e38-6070bb916ae6","cid":"0-0","title":"","parent":"0","errors":[]}],"suites":[],"parent":"login.feature:2:1","hooksAndTests":[{"type":"hook","start":"2024-08-03T17:11:35.300Z","end":"2024-08-03T17:11:35.305Z","_duration":5,"uid":"6b9e1096-83dd-4590-9c15-a57e9b1be861","cid":"0-0","title":"","parent":"0","errors":[]},{"type":"test","start":"2024-08-03T17:11:35.308Z","end":"2024-08-03T17:11:35.594Z","_duration":286,"uid":"88b3e9f2-8191-454a-b0ca-b196adc44066","cid":"0-0","title":"Given user already on login page","fullTitle":"0: Given user already on login page","output":[{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://kasirdemo.vercel.app/login"},"cid":"0-0","type":"command"},{"command":"navigateTo","method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://kasirdemo.vercel.app/login"},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-08-03T17:11:35.595Z","end":"2024-08-03T17:11:39.234Z","_duration":3639,"uid":"08658e70-4cc5-450b-a0f0-565706292fb9","cid":"0-0","title":"When user input valid login credentials with email \"dummyuser00@mail.com\" and password \"password\"","fullTitle":"0: When user input valid login credentials with email \"dummyuser00@mail.com\" and password \"password\"","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id= 'email']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id= 'email']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.2"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.2/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.2/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.2/value","body":{"text":"dummyuser00@mail.com"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.2/value","body":{"text":"dummyuser00@mail.com"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id= 'password']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//input[@id= 'password']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.3"}},"cid":"0-0","type":"result"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.3/clear","body":{},"cid":"0-0","type":"command"},{"command":"elementClear","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.3/clear","body":{},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.3/value","body":{"text":"password"},"cid":"0-0","type":"command"},{"command":"elementSendKeys","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.3/value","body":{"text":"password"},"result":{"value":null},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type= 'submit'][text()='login']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type= 'submit'][text()='login']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9"}},"cid":"0-0","type":"result"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9/property/value","body":{},"cid":"0-0","type":"command"},{"command":"getElementProperty","method":"GET","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9/property/value","body":{},"result":{"value":""},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type= 'submit'][text()='login']"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//button[@type= 'submit'][text()='login']"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9"}},"cid":"0-0","type":"result"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9/click","body":{},"cid":"0-0","type":"command"},{"command":"elementClick","method":"POST","endpoint":"/session/:sessionId/element/f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.9/click","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"test","start":"2024-08-03T17:11:39.236Z","end":"2024-08-03T17:11:42.141Z","_duration":2905,"uid":"db8fcf6d-d324-4ce0-9969-638906b2cde1","cid":"0-0","title":"Then user is successfully logged in and redirected to the dashboard page","fullTitle":"0: Then user is successfully logged in and redirected to the dashboard page","output":[{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\"method\":\"xpath\",\"selector\":\"//div[contains(text(),'dashboard')]\"}\n  (Session info: chrome=127.0.6533.89)","stacktrace":"\tGetHandleVerifier [0x00007FF6475A9632+30946]\n\t(No symbol) [0x00007FF64755E3C9]\n\t(No symbol) [0x00007FF647456FDA]\n\t(No symbol) [0x00007FF6474A822C]\n\t(No symbol) [0x00007FF6474A850C]\n\t(No symbol) [0x00007FF6474EDCB7]\n\t(No symbol) [0x00007FF6474CCAAF]\n\t(No symbol) [0x00007FF6474EB041]\n\t(No symbol) [0x00007FF6474CC813]\n\t(No symbol) [0x00007FF64749A6E5]\n\t(No symbol) [0x00007FF64749B021]\n\tGetHandleVerifier [0x00007FF6476DF83D+1301229]\n\tGetHandleVerifier [0x00007FF6476EBDB7+1351783]\n\tGetHandleVerifier [0x00007FF6476E2A03+1313971]\n\tGetHandleVerifier [0x00007FF6475DDD06+245686]\n\t(No symbol) [0x00007FF64756758F]\n\t(No symbol) [0x00007FF647563804]\n\t(No symbol) [0x00007FF647563992]\n\t(No symbol) [0x00007FF64755A3EF]\n\tBaseThreadInitThunk [0x00007FF8CA137374+20]\n\tRtlUserThreadStart [0x00007FF8CA9FCC91+33]\n"}},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11","ELEMENT":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11","ELEMENT":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"cid":"0-0","type":"command"},{"command":"findElement","method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"xpath","value":"//div[contains(text(),'dashboard')]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}},"cid":"0-0","type":"result"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11","ELEMENT":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}]},"cid":"0-0","type":"command"},{"command":"executeScript","method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) {\n            if (predicate(node)) {\n                return node;\n            }\n        }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if ('ShadowRoot' in window && element instanceof window.ShadowRoot) {\n            element = element.host;\n        }\n        const computedStyle = window.getComputedStyle(element);\n        const computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        const parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementHasBoundingBox(element) {\n        const boundingBox = element.getBoundingClientRect();\n        return boundingBox.width > 0 && boundingBox.height > 0;\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        if (elementHasBoundingBox(element)) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        const boundingBox = element.getBoundingClientRect();\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            const strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return [].some.call(element.childNodes, function (childNode) {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        const cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return [].every.call(element.childNodes, function (childNode) {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) &&\n        (\n        // IE doesn't support document.contains, therefor check before using\n        typeof document.contains === 'function'\n            ? !document.contains(element)\n            : !document.body.contains(element))) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            const enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, function (e) {\n                return e.tagName.toUpperCase() === 'SELECT';\n            });\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    const hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    const hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, function (e) {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element) && !elementHasBoundingBox(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11","ELEMENT":"f.FF60C59C9B2EE453EAACB0193D4E940C.d.A6A4DCF6DEE4DCE4A9DF37F15582FE2A.e.11"}]},"result":{"value":true},"cid":"0-0","type":"result"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"cid":"0-0","type":"command"},{"command":"deleteSession","method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"cid":"0-0","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0},{"type":"hook","start":"2024-08-03T17:11:42.143Z","end":"2024-08-03T17:11:42.146Z","_duration":3,"uid":"1d4774b3-3249-4d7e-8e38-6070bb916ae6","cid":"0-0","title":"","parent":"0","errors":[]}],"description":""}],"hooksAndTests":[],"description":""}],"reportFile":"E:\\github\\sbcode-wdio-cucumber-kasiraja\\reports\\html\\html-reports-20240804_0011\\master-report.html","browserName":"Chrome"}